# 8.1 Optimization Overview

在数据库的层面，数据库的性能由多个因素决定，诸如表，查询和配置等。这些软件构造会引起硬件层面的 CPU 和 I/O 操作，而你希望能最小化这些操作，让它尽可能的高效。当你致力于数据库的性能时，你要从软件方面高级规则和指南开始着手，并通过挂钟（wall-clock time）测量性能。当你成为一个专家后，你将更多的关注内部发生的事情，并开始测量像 CPU 周期和 I/O 操作等事项。  
通常的用户旨在他们现有的软硬件配置下获得最好的数据库性能。更高级的用户才会寻找机会去改善 MySQL 自身的软件，或是开发他们自己的存储引擎和硬件应用来拓展 MySQL 的生态系统。

- [数据库层面的优化]()
- [硬件层面的优化]()
- [平衡可移植性和性能]()

## 数据库层面的优化
让数据库应用变快最重要的因素就是它自身的设计：  
- 表的结构是否合理？特别是，列是否具有正确的数据类型，并且每个表是否具有合适工作的列？比如，频繁更新的应用程序通常需要许多具有很少列的表，但是分析大量数据的应用程序通常具有很少的表但是列却很多。
- 是否正确设置了索引让查询更高效?
- 你是否为每张表都设置了正确的存储引擎，并利用了你所使用的存储引擎的优势和特性？特别是，选择使用事务存储引擎（如 InnoDB ）或是非事务的存储引擎（如 MyISAM ）对性能和可扩展性至关重要。  
```
注意  
新的表默认的搜索引擎就是 InnoDB。实际上，先进的 InnoDB 性能特征意味比简单的 MyISAM 表有更好的性能，特别是对于繁忙的数据库。  
```
- 是否每张表都使用了正确的行格式？这同样取决于表的存储引擎。特别是，压缩过的表会使用较少的磁盘空间，因此也只需要更好的磁盘 I/O 来读写数据。压缩对于任意工作负载的 InnoDB 表和只读的 MyISAM 而言都是可行的。
- 应用程序是否使用了合适的锁策略？比如，通过允许可能的共同访问可以并行的运行数据库操作，并在适当时请求独占访问，让关键的操作得到高优先级。同样，存储引擎的选择至关重要。InnoDB 存储引擎可以在无需你的参与就处理大部分锁的问题，让数据库有更好的并发性并减少你代码的调试。
- 是否所有用来缓存的内存区域大小都设置正确？也就是说，要足够大来保存频繁访问的数据，但又不至于大到让物理内存过载并造成分页。主要的内存区域配置是 InnoDB 的缓冲池， MyISAM 的 key cache，和 MySQL 的查询缓存。  

## 硬件层面的优化  
任何数据库应用随着数据库变得越来越忙碌，最终都会打到硬件的现实。一个 DBA 必须要评估通过调整应用或是重新配置服务器来避免这些瓶颈是否是可行的，又或是他还需要更多的硬件资源。系统瓶颈通常来自下面这些原因：
- 磁盘搜索。从磁盘上查找某个数据片段是需要时间的。对于现代的磁盘，这个搜索时间通常低于10ms，因此理论上我们可以在1秒内查询大约100次。通过更新磁盘对这个时间的改善很小，并且它对单表的优化也十分困难。优化搜索时间的最佳方式是数据分布在多个磁盘上。
- 磁盘读写。当磁盘在正确的位置上时，我们需要读或写数据。现代的磁盘中，一个磁盘至少提供 10-20 MB/s 的吞吐量。 优化读写比优化搜索要来的容易，因为你可以从多个磁盘中并行的读。
- CPU 周期。当数据在主内存，我们必须处理这些数据并得到我们的结果。庞大的表在这点上通常更容易成为限制的因素。但对于小的表，速度通常不是问题。
- 内存带宽。当CPU需要数据超过CPU的缓存时，主存的贷款将成为瓶颈。对大多数的系统而言，这都不是常见的瓶颈，但我们也要意识到这一点。

## 平衡便携性和性能
要在可移植的 MySQL 程序中使用面向性能的 SQL 拓展，你可以将 MySQL 的特定的关键字包含在 `/*! */`评论分隔符中。其他的SQL 服务器会忽略掉这些关键字。关于写评论的内容见[9.6节，"Comment Syntax"](https://dev.mysql.com/doc/refman/5.7/en/comments.html)。